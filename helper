#include <PS4Controller.h>

#define STOP 0
#define FORWARD 1
#define REVERSE 2
#define TURNRF 3    //turn right forward
#define TURNLF 4    //turn left forward
#define TURNRR 5    //turn right reverse
#define TURNLR 6    //turn left reverse
#define PIVOTRF 7   //pivot right forward
#define PIVOTLF 8   //pivot left forward
#define PIVOTRR 9   //pivot right reverse
#define PIVOTLR 10  //pivot left reverse
#define SPINCL 11   //spins clock-wise
#define SPINCCL 12  // Spins councter-clockwise

// float readControllerData() {
//   // Below has all accessible outputs from the controller
//   if (PS4.isConnected()) {
//     if (PS4.Right()) return PS4.Right();
//     if (PS4.Down()) return PS4.Down();
//     if (PS4.Up()) return PS4.Up();
//     if (PS4.Left()) return PS4.Left();

//     if (PS4.Square()) return PS4.Square();
//     if (PS4.Cross()) return PS4.Cross();
//     if (PS4.Circle()) return PS4.Circle();
//     if (PS4.Triangle()) return PS4.Triangle();

//     if (PS4.UpRight()) return PS4.UpRight();
//     if (PS4.DownRight()) return PS4.DownRight();
//     if (PS4.UpLeft()) return PS4.UpLeft();
//     if (PS4.DownLeft()) return PS4.DownLeft();

//     if (PS4.L1()) Serial.println("L1 Button");
//     if (PS4.R1()) Serial.println("R1 Button");

//     if (PS4.Share()) Serial.println("Share Button");
//     if (PS4.Options()) Serial.println("Options Button");
//     if (PS4.L3()) Serial.println("L3 Button");
//     if (PS4.R3()) Serial.println("R3 Button");

//     if (PS4.PSButton()) Serial.println("PS Button");
//     if (PS4.Touchpad()) Serial.println("Touch Pad Button");

//     if (PS4.L2()) {
//       Serial.printf("L2 button at %d\n", PS4.L2Value());
//     }
//     if (PS4.R2()) {
//       Serial.printf("R2 button at %d\n", PS4.R2Value());
//     }

//     if (PS4.LStickX()) {
//       return PS4.LStickX();
//     }
//     if (PS4.LStickY()) {
//       return PS4.LStickY();
//     }
//     if (PS4.RStickX()) {
//       return PS4.RStickX();
//     }
//     if (PS4.RStickY()) {
//       return PS4.RStickY();
//     }

//     if (PS4.Charging()) Serial.println("The controller is charging");
//     if (PS4.Audio()) Serial.println("The controller has headphones attached");
//     if (PS4.Mic()) Serial.println("The controller has a mic attached");


//   } else {
//     Serial.println("The PS4 Controller is not connected");
//   }
//   delay(500);
// }

//below is an in progress find state by Refa

void find_btnState() {
  if (PS4.Down() == 0 && PS4.Up() == 0 && PS4.Cross() == 0 && PS4.Triangle() == 0 && PS4.Left() == 0 && PS4.Circle() == 0) {
    STATE = STOP;
  } else if (PS4.Up() == 1 && PS4.Triangle() == 1) {
    STATE = FORWARD;
  } else if (PS4.Down() == 1 && PS4.Cross() == 1) {
    STATE = REVERSE;
  } else if (PS4.Up() == 1 && PS4.Circle() == 1) {
    STATE = TURNRF;
  } else if (PS4.Triangle() == 1 && PS4.Left() == 1) {
    STATE = TURNLF;
  } else if (PS4.Down() == 1 && PS4.Circle() == 1) {
    STATE = TURNRR;
  } else if (PS4.Cross() == 1 && PS4.Left() == 1) {
    STATE = TURNLR;
  } else if (PS4.Down() == 0 && PS4.Up() == 1 && PS4.Cross() == 0 && PS4.Triangle() == 0 && PS4.Left() == 0 && PS4.Circle() == 0) {
    STATE = PIVOTRF;
  } else if (PS4.Down() == 0 && PS4.Up() == 0 && PS4.Cross() == 0 && PS4.Triangle() == 1 && PS4.Left() == 0 && PS4.Circle() == 0) {
    STATE = PIVOTLF;
  } else if (PS4.Down() == 1 && PS4.Up() == 0 && PS4.Cross() == 0 && PS4.Triangle() == 0 && PS4.Left() == 0 && PS4.Circle() == 0) {
    STATE = PIVOTRR;
  } else if (PS4.Down() == 0 && PS4.Up() == 0 && PS4.Cross() == 1 && PS4.Triangle() == 0 && PS4.Left() == 0 && PS4.Circle() == 0) {
    STATE = PIVOTLR;
  } else if (PS4.Up() == 1 && PS4.Cross() == 1) {
    STATE = SPINCL;
  } else if (PS4.Down() == 1 && PS4.Triangle() == 1) {
    STATE = SPINCCL;
  }
}

void find_joyState() {
  if (joystick_LYValue == 1 && joystick_RYValue == 1) {
    STATE = STOP;
  } else if (joystick_LYValue > 1 && joystick_RYValue > 1) {
    STATE = FORWARD;
  } else if (joystick_LYValue < 1 && joystick_RYValue < 1) {
    STATE = REVERSE;
  } else if (joystick_LYValue > 1 && joystick_RYValue > 0) {
    STATE = TURNRF;
  } else if (joystick_LYValue > 1 && joystick_RYValue) {
    STATE = TURNLF;
  } else if (joystick_LYValue < 1 && joystick_RYValue > 0) {
    STATE = TURNRR;
  }
}

//below is an in progress joystick reading by Refa

float read_LXValue() {
  if (PS4.LStickX()) {
    return PS4.LStickX();
  }
}

float read_LYValue() {
  if (PS4.LStickY()) {
    return PS4.LStickY();
  }
}

float read_RXValue() {
  if (PS4.RStickX()) {
    return PS4.RStickY();
  }
}

float read_RYValue() {
  if (PS4.RStickY()) {
    return PS4.RStickY();
  }
}

// Below is Braeden's switch case functions

void run_STOP() {
  // ledcWrite(rightMotorDIRPin, 0);
  // ledcWrite(leftMotorDIRPin, 0);
  // ledcWrite(rightMotorPWMPin, 0);
  // ledcWrite(leftMotorPWMPin, 0);
  // pwmDutyCycle = 0;
  gpioExt.digitalWrite(nSLPLPin, LOW);
  gpioExt.digitalWrite(nSLPRPin, LOW);
}

void run_FORWARD() {
  // ledcWrite(rightMotorDIRPin, 100);
  // ledcWrite(leftMotorDIRPin, 100);
  // ledcWrite(rightMotorPWMPin, 0);
  // ledcWrite(leftMotorPWMPin, 0);

  gpioExt.digitalWrite(nSLPLPin, HIGH);
  gpioExt.digitalWrite(nSLPRPin, HIGH);
  digitalWrite(rightMotorDIRPin, REV);
  digitalWrite(leftMotorDIRPin, REV);
  pwmGoLowCount = 0.01 * pwmDutyCycle * motorPwmMaxCount;
  ledcWrite(rightMotorPWMPin, pwmGoLowCount);
  ledcWrite(leftMotorPWMPin, pwmGoLowCount);
}

void run_REVERSE() {
  // ledcWrite(rightMotorDIRPin, 0);
  // ledcWrite(leftMotorDIRPin, 0);
  // ledcWrite(rightMotorPWMPin, 100);
  // ledcWrite(leftMotorPWMPin, 100);

  gpioExt.digitalWrite(nSLPLPin, HIGH);
  gpioExt.digitalWrite(nSLPRPin, HIGH);
  digitalWrite(rightMotorDIRPin, FWD);
  digitalWrite(leftMotorDIRPin, FWD);
  pwmGoLowCount = 0.01 * pwmDutyCycle * motorPwmMaxCount;
  ledcWrite(rightMotorPWMPin, pwmGoLowCount);
  ledcWrite(leftMotorPWMPin, pwmGoLowCount);
}

void run_TURNRF() {
  gpioExt.digitalWrite(nSLPLPin, HIGH);
  gpioExt.digitalWrite(nSLPRPin, HIGH);
  digitalWrite(rightMotorDIRPin, REV);
  digitalWrite(leftMotorDIRPin, REV);
  pwmGoLowCount = 0.01 * pwmDutyCycle * motorPwmMaxCount;
  ledcWrite(rightMotorPWMPin, pwmGoLowCount);
  ledcWrite(leftMotorPWMPin, pwmGoLowCount*0.5);
}

void run_TURNLF() {
  // ledcWrite(rightMotorDIRPin, 50);
  // ledcWrite(leftMotorDIRPin, 100);
  // ledcWrite(rightMotorPWMPin, 0);
  // ledcWrite(leftMotorPWMPin, 0);

  gpioExt.digitalWrite(nSLPLPin, HIGH);
  gpioExt.digitalWrite(nSLPRPin, HIGH);
  digitalWrite(rightMotorDIRPin, REV);
  digitalWrite(leftMotorDIRPin, REV);
  pwmGoLowCount = 0.01 * pwmDutyCycle * motorPwmMaxCount;
  ledcWrite(rightMotorPWMPin, pwmGoLowCount*0.5);
  ledcWrite(leftMotorPWMPin, pwmGoLowCount);
}

void run_TURNRR() {
  //ledcWrite(rightMotorDIRPin, 0);
  //ledcWrite(leftMotorDIRPin, 0);
  //ledcWrite(rightMotorPWMPin, 100);
  //ledcWrite(leftMotorPWMPin, 50);

  gpioExt.digitalWrite(nSLPLPin, HIGH);
  gpioExt.digitalWrite(nSLPRPin, HIGH);
  digitalWrite(rightMotorDIRPin, FWD);
  digitalWrite(leftMotorDIRPin, FWD);
  pwmGoLowCount = 0.01 * pwmDutyCycle * motorPwmMaxCount;
  ledcWrite(rightMotorPWMPin, pwmGoLowCount);
  ledcWrite(leftMotorPWMPin, pwmGoLowCount*0.5);
}

void run_TURNLR() {
  // ledcWrite(rightMotorDIRPin, 0);
  // ledcWrite(leftMotorDIRPin, 0);
  // ledcWrite(rightMotorPWMPin, 50);
  // ledcWrite(leftMotorPWMPin, 100);

  gpioExt.digitalWrite(nSLPLPin, HIGH);
  gpioExt.digitalWrite(nSLPRPin, HIGH);
  digitalWrite(rightMotorDIRPin, FWD);
  digitalWrite(leftMotorDIRPin, FWD);
  pwmGoLowCount = 0.01 * pwmDutyCycle * motorPwmMaxCount;
  ledcWrite(rightMotorPWMPin, pwmGoLowCount*0.5);
  ledcWrite(leftMotorPWMPin, pwmGoLowCount);
}

void run_PIVOTRF() {
  gpioExt.digitalWrite(nSLPLPin, LOW);
  gpioExt.digitalWrite(nSLPRPin, HIGH);
  digitalWrite(rightMotorDIRPin, REV);
  digitalWrite(leftMotorDIRPin, FWD);
  pwmGoLowCount = 0.01 * pwmDutyCycle * motorPwmMaxCount;
  ledcWrite(rightMotorPWMPin, pwmGoLowCount);
  ledcWrite(leftMotorPWMPin, pwmGoLowCount);
}

void run_PIVOTLF() {
  gpioExt.digitalWrite(nSLPLPin, HIGH);
  gpioExt.digitalWrite(nSLPRPin, LOW);
  digitalWrite(rightMotorDIRPin, FWD);
  digitalWrite(leftMotorDIRPin, REV);
  pwmGoLowCount = 0.01 * pwmDutyCycle * motorPwmMaxCount;
  ledcWrite(rightMotorPWMPin, pwmGoLowCount);
  ledcWrite(leftMotorPWMPin, pwmGoLowCount);
}

void run_PIVOTRR() {
  gpioExt.digitalWrite(nSLPLPin, LOW);
  gpioExt.digitalWrite(nSLPRPin, HIGH);
  digitalWrite(rightMotorDIRPin, FWD);
  digitalWrite(leftMotorDIRPin, FWD);
  pwmGoLowCount = 0.01 * pwmDutyCycle * motorPwmMaxCount;
  ledcWrite(rightMotorPWMPin, pwmGoLowCount);
  ledcWrite(leftMotorPWMPin, pwmGoLowCount);
}

void run_PIVOTLR() {
  gpioExt.digitalWrite(nSLPLPin, HIGH);
  gpioExt.digitalWrite(nSLPRPin, LOW);
  digitalWrite(rightMotorDIRPin, FWD);
  digitalWrite(leftMotorDIRPin, FWD);
  pwmGoLowCount = 0.01 * pwmDutyCycle * motorPwmMaxCount;
  ledcWrite(rightMotorPWMPin, pwmGoLowCount);
  ledcWrite(leftMotorPWMPin, pwmGoLowCount);
}

void run_SPINCL() {
  gpioExt.digitalWrite(nSLPLPin, HIGH);
  gpioExt.digitalWrite(nSLPRPin, HIGH);
  digitalWrite(rightMotorDIRPin, REV);
  digitalWrite(leftMotorDIRPin, FWD);
  pwmGoLowCount = 0.01 * pwmDutyCycle * motorPwmMaxCount;
  ledcWrite(rightMotorPWMPin, pwmGoLowCount);
  ledcWrite(leftMotorPWMPin, pwmGoLowCount);
}

void run_SPINCCL() {
  gpioExt.digitalWrite(nSLPLPin, HIGH);
  gpioExt.digitalWrite(nSLPRPin, HIGH);
  digitalWrite(rightMotorDIRPin, FWD);
  digitalWrite(leftMotorDIRPin, REV);
  pwmGoLowCount = 0.01 * pwmDutyCycle * motorPwmMaxCount;
  ledcWrite(rightMotorPWMPin, pwmGoLowCount);
  ledcWrite(leftMotorPWMPin, pwmGoLowCount);
}

/*
------------------------------------------------------------Below are the functions for the joy state------------------------------------------------------------------------------
*/

void run_joySTOP() {
  // ledcWrite(rightMotorDIRPin, 0);
  // ledcWrite(leftMotorDIRPin, 0);
  // ledcWrite(rightMotorPWMPin, 0);
  // ledcWrite(leftMotorPWMPin, 0);
  // pwmDutyCycle = 0;
  gpioExt.digitalWrite(nSLPLPin, LOW);
  gpioExt.digitalWrite(nSLPRPin, LOW);
}

void run_joyFORWARD() {
  // ledcWrite(rightMotorDIRPin, 100);
  // ledcWrite(leftMotorDIRPin, 100);
  // ledcWrite(rightMotorPWMPin, 0);
  // ledcWrite(leftMotorPWMPin, 0);
  gpioExt.digitalWrite(nSLPLPin, HIGH);
  gpioExt.digitalWrite(nSLPRPin, HIGH);
  digitalWrite(rightMotorDIRPin, REV);
  digitalWrite(leftMotorDIRPin, REV);
  pwmGoLowCountL = 0.01 * pwmDutyCycleL * motorPwmMaxCount;
  pwmGoLowCountR = 0.01 * pwmDutyCycleR * motorPwmMaxCount;
  ledcWrite(rightMotorPWMPin, pwmGoLowCountR);
  ledcWrite(leftMotorPWMPin, pwmGoLowCountL);
}

void run_joyREVERSE() {
  // ledcWrite(rightMotorDIRPin, 0);
  // ledcWrite(leftMotorDIRPin, 0);
  // ledcWrite(rightMotorPWMPin, 100);
  // ledcWrite(leftMotorPWMPin, 100);

  gpioExt.digitalWrite(nSLPLPin, HIGH);
  gpioExt.digitalWrite(nSLPRPin, HIGH);
  digitalWrite(rightMotorDIRPin, HIGH);
  digitalWrite(leftMotorDIRPin, HIGH);
  pwmGoLowCountL = 0.01 * pwmDutyCycleL * motorPwmMaxCount;
  pwmGoLowCountR = 0.01 * pwmDutyCycleR * motorPwmMaxCount;
  ledcWrite(rightMotorPWMPin, pwmGoLowCountR);
  ledcWrite(leftMotorPWMPin, pwmGoLowCountL);
}

void run_joyTURNRF() {
  gpioExt.digitalWrite(nSLPLPin, HIGH);
  gpioExt.digitalWrite(nSLPRPin, HIGH);
  digitalWrite(rightMotorDIRPin, FWD);
  digitalWrite(leftMotorDIRPin, FWD);
  pwmGoLowCountL = 0.01 * pwmDutyCycleL * motorPwmMaxCount;
  pwmGoLowCountR = 0.01 * pwmDutyCycleR * motorPwmMaxCount;
  ledcWrite(rightMotorPWMPin, pwmGoLowCountR);
  ledcWrite(leftMotorPWMPin, pwmGoLowCountL);
}

void run_joyTURNLF() {
  ledcWrite(rightMotorDIRPin, 50);
  ledcWrite(leftMotorDIRPin, 100);
  ledcWrite(rightMotorPWMPin, 0);
  ledcWrite(leftMotorPWMPin, 0);
}

void run_joyTURNRR() {
  ledcWrite(rightMotorDIRPin, 0);
  ledcWrite(leftMotorDIRPin, 0);
  ledcWrite(rightMotorPWMPin, 100);
  ledcWrite(leftMotorPWMPin, 50);
}

void run_joyTURNLR() {
  ledcWrite(rightMotorDIRPin, 0);
  ledcWrite(leftMotorDIRPin, 0);
  ledcWrite(rightMotorPWMPin, 50);
  ledcWrite(leftMotorPWMPin, 100);
}

void run_joyPIVOTRF() {
  gpioExt.digitalWrite(nSLPLPin, LOW);
  gpioExt.digitalWrite(nSLPRPin, HIGH);
  digitalWrite(rightMotorDIRPin, REV);
  digitalWrite(leftMotorDIRPin, FWD);
  pwmGoLowCount = 0.01 * pwmDutyCycle * motorPwmMaxCount;
  ledcWrite(rightMotorPWMPin, pwmGoLowCount);
  ledcWrite(leftMotorPWMPin, pwmGoLowCount);
}

void run_joyPIVOTLF() {
  gpioExt.digitalWrite(nSLPLPin, HIGH);
  gpioExt.digitalWrite(nSLPRPin, LOW);
  digitalWrite(rightMotorDIRPin, FWD);
  digitalWrite(leftMotorDIRPin, REV);
  pwmGoLowCount = 0.01 * pwmDutyCycle * motorPwmMaxCount;
  ledcWrite(rightMotorPWMPin, pwmGoLowCount);
  ledcWrite(leftMotorPWMPin, pwmGoLowCount);
}

void run_joyPIVOTRR() {
  gpioExt.digitalWrite(nSLPLPin, LOW);
  gpioExt.digitalWrite(nSLPRPin, HIGH);
  digitalWrite(rightMotorDIRPin, FWD);
  digitalWrite(leftMotorDIRPin, FWD);
  pwmGoLowCount = 0.01 * pwmDutyCycle * motorPwmMaxCount;
  ledcWrite(rightMotorPWMPin, pwmGoLowCount);
  ledcWrite(leftMotorPWMPin, pwmGoLowCount);
}

void run_joyPIVOTLR() {
  gpioExt.digitalWrite(nSLPLPin, HIGH);
  gpioExt.digitalWrite(nSLPRPin, LOW);
  digitalWrite(rightMotorDIRPin, FWD);
  digitalWrite(leftMotorDIRPin, FWD);
  pwmGoLowCount = 0.01 * pwmDutyCycle * motorPwmMaxCount;
  ledcWrite(rightMotorPWMPin, pwmGoLowCount);
  ledcWrite(leftMotorPWMPin, pwmGoLowCount);
}
