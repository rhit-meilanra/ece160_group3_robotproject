#include <Adafruit_MCP23X17.h>
Adafruit_MCP23X17 gpioExt;
#include <PS4Controller.h>
#include <Adafruit_PWMServoDriver.h>

#define pca9685PwmBits 12
#define minPW 500
#define maxPW 2500
#define servoFreq 50
#define clawServoNum 0
#define ON_COUNT 0
#define oscFreq 27000000
#define toFrac 0.000001

const int pwm0DegCount = toFrac * minPW * servoFreq * pow(2, pca9685PwmBits);
const int pwm180DegCount = toFrac * maxPW * servoFreq * pow(2, pca9685PwmBits);
const int pwm90DegCount = (pwm0DegCount + pwm180DegCount) / 2;
int angle = 90;
int angleCount;
const int i2cAddress = 0x40;
Adafruit_PWMServoDriver pwmExt = Adafruit_PWMServoDriver(i2cAddress);

#define bumper0 0
#define bumper1 1
#define bumper2 2
#define bumper3 3
#define bumper4 4
#define bumper5 5

int gpioExtPins[6] = {bumper0, bumper1, bumper2, bumper3, bumper4, bumper5};

// Below are the states for the robot, written by Refail Meilandry on 10/6/2025 12:25pm
#define BUTTON_MODE 100
#define JOYSTICK_MODE -1
#define STOP 0
#define FORWARD 1
#define REVERSE 2
#define TURNRF 3    //turn right forward
#define TURNLF 4    //turn left forward
#define TURNRR 5    //turn right reverse
#define TURNLR 6    //turn left reverse
#define PIVOTRF 7   //pivot right forward
#define PIVOTLF 8   //pivot left forward
#define PIVOTRR 9   //pivot right reverse
#define PIVOTLR 10  //pivot left reverse
#define SPINCL 11   //spins clock-wise
#define SPINCCL 12  // Spins councter-clockwise
int STATE = STOP;
int MODE = BUTTON_MODE;

#define GPB0 8
#define GPB1 9
#define nSLPLPin GPB0
#define nSLPRPin GPB1
#define rightMotorDIRPin 15
#define rightMotorPWMPin 13
#define leftMotorDIRPin 14
#define leftMotorPWMPin 12
#define motorFreq 500
#define motorPwmBits 8
#define FWD LOW
#define REV HIGH
const int motorPwmMaxCount = pow(2, motorPwmBits);
int pwmGoLowCount;
float pwmGoLowCountL;
float pwmGoLowCountR;
int pwmDutyCycle;
float pwmDutyCycleL;
float pwmDutyCycleR;

int baudrate = 115200;
float read_RYValue();
float read_RXValue();
float read_LYValue();
float read_LXValue();
float joystick_LYValue;
float joystick_RYValue;


void setup() {
  Serial.begin(baudrate);
  gpioExt.begin_I2C(0x20);
  gpioExt.pinMode(nSLPLPin, OUTPUT);
  gpioExt.pinMode(nSLPRPin, OUTPUT);
  gpioExt.digitalWrite(nSLPLPin, LOW);
  gpioExt.digitalWrite(nSLPRPin, LOW);
  pinMode(rightMotorDIRPin, OUTPUT);
  pinMode(leftMotorDIRPin, OUTPUT);
  pinMode(rightMotorPWMPin, OUTPUT);
  pinMode(leftMotorPWMPin, OUTPUT);
  ledcAttach(rightMotorPWMPin, motorFreq, motorPwmBits);
  ledcAttach(leftMotorPWMPin, motorFreq, motorPwmBits);
  PS4.begin();

  // pwmExt.begin();
  // pwmExt.setOscillatorFrequency(oscFreq);
  // pwmExt.setPWMFreq(servoFreq);
  // pwmExt.setPWM(clawServoNum, ON_COUNT, pwm90DegCount);

  // Serial.println("Enter the claw servo angle in degrees from 0-180: ");

  // gpioExt.begin_I2C(0x20);
  // for (int i = 0; i < 6; i++) {
  //   gpioExt.pinMode(gpioExtPins[i], INPUT_PULLUP);
  // }
  // Serial.println("Reading Bumper Switches");
}

void loop() {
  // if(Serial.available() > 1) {
  //   angle = Serial.parseInt();
  //   Serial.print("The angle is: ");
  //   Serial.println(angle);
  // }
  // if ((angle >= 0) && (angle <= 180)) {
  //   angleCount = map(angle, 0, 180, pwm0DegCount, pwm180DegCount);
  //   pwmExt.setPWM(clawServoNum, ON_COUNT, angleCount);
  // } else {
  //   Serial.println("invalid");
  //   pwmExt.setPWM(clawServoNum, ON_COUNT, pwm90DegCount);
  // }

  // for (int i = 5; i > -1; i--) {
  //   Serial.print(gpioExt.digitalRead(gpioExtPins[i]));
  //   Serial.print("\t ");
  // }
  // Serial.print(gpioExt.readGPIOA(), BIN);
  // Serial.println();
  // delay(500);
  // if (Serial.available() >= 1) {
  //   pwmDutyCycle = Serial.parseInt();
  //   Serial.print("The duty cycle is: ");
  //   Serial.println(pwmDutyCycle);
  // }
  // if ((pwmDutyCycle >= 0) && (pwmDutyCycle <= 100)) {
  //   gpioExt.digitalWrite(nSLPLPin, HIGH);
  //   gpioExt.digitalWrite(nSLPRPin, HIGH);
  //   digitalWrite(rightMotorDIRPin, REV);
  //   digitalWrite(leftMotorDIRPin, REV);
  //   pwmGoLowCount = 0.01 * pwmDutyCycle * motorPwmMaxCount;
  //   ledcWrite(rightMotorPWMPin, pwmGoLowCount);
  //   ledcWrite(leftMotorPWMPin, pwmGoLowCount);
  // } else {
  //   Serial.println("You entered an invalid Duty Cycle: setting it to ");
  //   pwmDutyCycle = 0;
  //   gpioExt.digitalWrite(nSLPLPin, LOW);
  //   gpioExt.digitalWrite(nSLPRPin, LOW);
  // }

  switch (MODE) {
    case BUTTON_MODE:
      pwmDutyCycle = 50;
      switch (STATE) {
        case STOP:
          run_STOP();
          find_btnState();
          break;
        case FORWARD:
          run_FORWARD();
          find_btnState();
          break;
        case REVERSE:
          run_REVERSE();
          find_btnState();
          break;
        case TURNRF:
          run_TURNRF();
          find_btnState();
          break;
        case TURNLF:
          run_TURNLF();
          find_btnState();
          break;
        case TURNRR:
          run_TURNRR();
          find_btnState();
          break;
        case TURNLR:
          run_TURNLR();
          find_btnState();
          break;
        case PIVOTRF:
          run_PIVOTRF();
          find_btnState();
          break;
        case PIVOTLF:
          run_PIVOTLF();
          find_btnState();
          break;
        case PIVOTRR:
          run_PIVOTRR();
          find_btnState();
          break;
        case PIVOTLR:
          run_PIVOTLR();
          find_btnState();
          break;
        case SPINCL:
          run_SPINCL();
          find_btnState();
          break;
        case SPINCCL:
          run_SPINCCL();
          find_btnState();
          break;
        default:
          break;
      }
      if (PS4.Touchpad()) MODE = JOYSTICK_MODE;
      break;
    case JOYSTICK_MODE:
      joystick_LYValue = read_LYValue();
      joystick_RYValue = read_RYValue();
      pwmDutyCycleL = constrain(abs(joystick_LYValue), 0, 100);
      pwmDutyCycleR = constrain(abs(joystick_RYValue), 0, 100);
      switch (STATE) {
        case STOP:
          run_joySTOP();
          find_joyState();
          break;
        case FORWARD:
          run_joyFORWARD();
          find_joyState();
          break;
        case REVERSE:
          run_REVERSE();
          find_joyState();
          break;
        case TURNRF:
          run_TURNRF();
          find_joyState();
          break;
        case TURNLF:
          run_TURNLF();
          find_joyState();
          break;
        case TURNRR:
          run_TURNRR();
          find_joyState();
          break;
        case TURNLR:
          run_TURNLR();
          find_joyState();
          break;
        case PIVOTRF:
          run_PIVOTRF();
          find_joyState();
          break;
        case PIVOTLF:
          run_PIVOTLF();
          find_joyState();
          break;
        case PIVOTRR:
          run_PIVOTRR();
          find_joyState();
          break;
        case PIVOTLR:
          run_PIVOTLR();
          find_joyState();
          break;
        case SPINCL:
          run_SPINCL();
          find_joyState();
          break;
        case SPINCCL:
          run_SPINCCL();
          find_joyState();
          break;
        default:
          break;
      }
      if (PS4.Touchpad()) MODE = BUTTON_MODE;
      break;
    default:
      break;
  }
}
