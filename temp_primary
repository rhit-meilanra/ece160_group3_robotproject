#include <Adafruit_MCP23X17.h>
Adafruit_MCP23X17 gpioExt;
#include <PS4Controller.h>
#include <Adafruit_PWMServoDriver.h>
#include <QTRSensors.h>

#define encoderLAPin 32
#define encoderRAPin 35
#define encoderLBPin 34
#define encoderRBPin 33

float positionL, positionR;
long encoderRcount = 0;
long encoderLcount = 0;

bool encoderRdir, encoderLdir;

#define nSensors 8
#define ctrlEven 5
#define ctrlOdd 25
#define waitTime 2000
const uint8_t sensorPins[] = { 26, 27, 4, 16, 17, 18, 19, 23 };
QTRSensors qtrArray;
uint16_t sensorValues[nSensors];
uint16_t sensorValuesCalibrated[nSensors];
#define ALIGNED 0
#define OFF_LEFT 1
#define OFF_RIGHT 2
#define LINETURN_LEFT 3
#define LINETURN_RIGHT 4
#define LOST 5
#define PARKED 6
int LINESTATE = PARKED;

/*
----------------------------------------------------------------------------Above are Defined vlaues for the SENSOR FOR LINE READING-------------------------
*/

#define pca9685PwmBits 12
#define minPW 500
#define maxPW 2500
#define servoFreq 50
#define clawServoNum 0
#define ON_COUNT 0
#define oscFreq 27000000
#define toFrac 0.000001
#define CLOSED 0
#define OPENED 1
int CLAWSTATE = OPENED;

const int pwm0DegCount = toFrac * minPW * servoFreq * pow(2, pca9685PwmBits);
const int pwm180DegCount = toFrac * maxPW * servoFreq * pow(2, pca9685PwmBits);
const int pwm90DegCount = (pwm0DegCount + pwm180DegCount) / 2;
int angle = 90;
int angleCount;
const int i2cAddress = 0x40;
Adafruit_PWMServoDriver pwmExt = Adafruit_PWMServoDriver(i2cAddress);

/*
--------------------------------------------------------------------------Above are the defined values for the SERVO CLAW--------------------------------
*/

#define bumper0 0
#define bumper1 1
#define bumper2 2
#define bumper3 3
#define bumper4 4
#define bumper5 5
int bumperstate;

int gpioExtPins[6] = { bumper0, bumper1, bumper2, bumper3, bumper4, bumper5 };

/*
--------------------------------------------------------------------------Above are the defined values for the REAR BUMPERS--------------------------------
*/

#define BUTTON_MODE 100
#define JOYSTICK_MODE -1
#define STOP 0
#define FORWARD 1
#define REVERSE 2
#define TURNRF 3    //turn right forward
#define TURNLF 4    //turn left forward
#define TURNRR 5    //turn right reverse
#define TURNLR 6    //turn left reverse
#define PIVOTRF 7   //pivot right forward
#define PIVOTLF 8   //pivot left forward
#define PIVOTRR 9   //pivot right reverse
#define PIVOTLR 10  //pivot left reverse
#define SPINCL 11   //spins clock-wise
#define SPINCCL 12  // Spins councter-clockwise
#define SPACE 13
#define CONTACT 14
int BODY = SPACE;
int STATE = STOP;
int MODE = BUTTON_MODE;
/*
--------------------------------------------------------------------------Above are the defined values for the STATES OF THE ROBOT MOVEMENT--------------------------------
*/
#define GPB0 8
#define GPB1 9
#define nSLPLPin GPB0
#define nSLPRPin GPB1
#define rightMotorDIRPin 15
#define rightMotorPWMPin 13
#define leftMotorDIRPin 14
#define leftMotorPWMPin 12
#define motorFreq 500
#define motorPwmBits 8
#define FWD LOW
#define REV HIGH
const int motorPwmMaxCount = pow(2, motorPwmBits);
int pwmGoLowCount;
float pwmGoLowCountL;
float pwmGoLowCountR;
int pwmDutyCycle;
float pwmDutyCycleL;
float pwmDutyCycleR;
/*
--------------------------------------------------------------------------Above are the defined values for the MOTORS--------------------------------
*/
int baudrate = 115200;
float read_RYValue();
float read_RXValue();
float read_LYValue();
float read_LXValue();
float joystick_LYValue;
float joystick_RYValue;


void setup() {
  Serial.begin(baudrate);
  gpioExt.begin_I2C(0x20);
  gpioExt.pinMode(nSLPLPin, OUTPUT);
  gpioExt.pinMode(nSLPRPin, OUTPUT);
  gpioExt.digitalWrite(nSLPLPin, LOW);
  gpioExt.digitalWrite(nSLPRPin, LOW);
  pinMode(rightMotorDIRPin, OUTPUT);
  pinMode(leftMotorDIRPin, OUTPUT);
  pinMode(rightMotorPWMPin, OUTPUT);
  pinMode(leftMotorPWMPin, OUTPUT);
  ledcAttach(rightMotorPWMPin, motorFreq, motorPwmBits);
  ledcAttach(leftMotorPWMPin, motorFreq, motorPwmBits);
  PS4.begin();

/*
--------------------------------------------------------------------------Above are the setup functions to get the motor ready to run--------------------------------
*/
  pwmExt.begin();
  pwmExt.setOscillatorFrequency(oscFreq);
  pwmExt.setPWMFreq(servoFreq);
  pwmExt.setPWM(clawServoNum, ON_COUNT, pwm90DegCount);
/*
--------------------------------------------------------------------------Above ar ethe defined functions for the SERVO CLAW--------------------------------
*/
  gpioExt.begin_I2C(0x20);
  for (int i = 0; i < 6; i++) {
    gpioExt.pinMode(gpioExtPins[i], INPUT_PULLUP);
  }
/*
--------------------------------------------------------------------------Above are the defined values for the REAR BUMPERS--------------------------------
*/
  qtrArray.setTypeRC();
  qtrArray.setSensorPins(sensorPins, nSensors);
  qtrArray.setEmitterPins(ctrlOdd, ctrlEven);
  Serial.println("Staring Calculation");
  for (int i = 0; i < 400; i++) {
    qtrArray.calibrate();
  }
  Serial.println("Calibrated");

  pinMode(encoderLAPin, INPUT_PULLDOWN);
  pinMode(encoderRAPin, INPUT_PULLDOWN);
  pinMode(encoderLBPin, INPUT_PULLDOWN);
  pinMode(encoderRBPin, INPUT_PULLDOWN);
  attachInterrupt(digitalPinToInterrupt(encoderRBPin), triggerRightEncoder, RISING);
  attachInterrupt(digitalPinToInterrupt(encoderLBPin), triggerLeftEncoder, RISING);
}

void loop() {
  // float newL2 = PS4.L2Value();
  // angleCount = map(newL2, 0, 255, pwm0DegCount, pwm180DegCount);
  // pwmExt.setPWM(clawServoNum, ON_COUNT, angleCount);
  // Serial.println(angleCount);

  positionR = encoderRcount;
  positionL = encoderLcount;
  Serial.print(positionL);
  Serial.print("  ||  ");
  Serial.println(positionR);

  qtrArray.read(sensorValues);
  qtrArray.readCalibrated(sensorValuesCalibrated);
  for (int i = 0; i < 8; i++) {
    Serial.print(sensorValues[i]);
    Serial.print(" ");
  }
/*
------------------------------------------------------------------------------------------------------ABOVE IS READ SENSOR VALUES-----------------------------------------------------------------------------
*/
  switch (LINESTATE) {
    case PARKED:
      run_STOP();
      find_LINESTATE();
      break;
    case ALIGNED:
      pwmDutyCycle = 50;
      run_FORWARD();
      find_LINESTATE();
      Serial.println("ALIGNED");
      break;
    case OFF_RIGHT:
      pwmDutyCycle = 50;
      run_PIVOTLF();
      find_LINESTATE();
      Serial.println("OFF_RIGHT");
      break;
    case OFF_LEFT:
      pwmDutyCycle = 50;
      run_PIVOTRF();
      find_LINESTATE();
      Serial.println("OFF_LEFT");
      break;
    default:
      run_STOP();
      find_LINESTATE();
      break;
  }

/*
-----------------------------------------------------------------------------ABOVE IS LINE FOLLOWING----------------------------------------------------------------------------------------
*/

  switch (CLAWSTATE) {
    case OPENED:
      run_openclaw();
      find_CLAWSTATE();
      break;
    case CLOSED:
      run_closeclaw();
      find_CLAWSTATE();
      break;
    default:
      break;
  }
/*
--------------------------------------------------------------------------Above is the state case statements for the CLAW, every case will detect what the next state will be----------
--------------------------------------------------------------------------and depending on the state, will either open or close--------------------------------
*/
  // if (Serial.available() > 1) {
  //   angle = Serial.parseInt();
  //   Serial.print("The angle is: ");
  //   Serial.println(angle);
  // }
  // if ((angle >= 0) && (angle <= 180)) {
  //   angleCount = map(angle, 0, 180, pwm0DegCount, pwm180DegCount);
  //   pwmExt.setPWM(clawServoNum, ON_COUNT, angleCount);
  // } else {
  //   Serial.println("invalid");
  //   pwmExt.setPWM(clawServoNum, ON_COUNT, pwm90DegCount);
  // }

  // for (int i = 5; i > -1; i--) {
  //   Serial.print(gpioExt.digitalRead(gpioExtPins[i]));
  //   Serial.print("\t ");
  // }
  // bumperstate = gpioExt.readGPIOA();
  // if (bumperstate != 63){
  //   BODY = CONTACT;
  // }
  // Serial.println();
  // delay(500);

  // if (Serial.available() >= 1) {
  //   pwmDutyCycle = Serial.parseInt();
  //   Serial.print("The duty cycle is: ");
  //   Serial.println(pwmDutyCycle);
  // }
  // if ((pwmDutyCycle >= 0) && (pwmDutyCycle <= 100)) {
  //   gpioExt.digitalWrite(nSLPLPin, HIGH);
  //   gpioExt.digitalWrite(nSLPRPin, HIGH);
  //   digitalWrite(rightMotorDIRPin, REV);
  //   digitalWrite(leftMotorDIRPin, REV);
  //   pwmGoLowCount = 0.01 * pwmDutyCycle * motorPwmMaxCount;
  //   ledcWrite(rightMotorPWMPin, pwmGoLowCount);
  //   ledcWrite(leftMotorPWMPin, pwmGoLowCount);
  // } else {
  //   Serial.println("You entered an invalid Duty Cycle: setting it to ");
  //   pwmDutyCycle = 0;
  //   gpioExt.digitalWrite(nSLPLPin, LOW);
  //   gpioExt.digitalWrite(nSLPRPin, LOW);
  // }

  switch (MODE) {
    case BUTTON_MODE:
      pwmDutyCycle = 50;
      switch (STATE) {
        case STOP:
          run_STOP();
          find_btnState();
          break;
        case FORWARD:
          run_FORWARD();
          find_btnState();
          break;
        case REVERSE:
          run_REVERSE();
          find_btnState();
          break;
        case TURNRF:
          run_TURNRF();
          find_btnState();
          break;
        case TURNLF:
          run_TURNLF();
          find_btnState();
          break;
        case TURNRR:
          run_TURNRR();
          find_btnState();
          break;
        case TURNLR:
          run_TURNLR();
          find_btnState();
          break;
        case PIVOTRF:
          run_PIVOTRF();
          find_btnState();
          break;
        case PIVOTLF:
          run_PIVOTLF();
          find_btnState();
          break;
        case PIVOTRR:
          run_PIVOTRR();
          find_btnState();
          break;
        case PIVOTLR:
          run_PIVOTLR();
          find_btnState();
          break;
        case SPINCL:
          run_SPINCL();
          find_btnState();
          break;
        case SPINCCL:
          run_SPINCCL();
          find_btnState();
          break;
        default:
          break;
      }
      if (PS4.Touchpad()) MODE = JOYSTICK_MODE;
      break;
    case JOYSTICK_MODE:
      joystick_LYValue = read_LYValue();
      joystick_RYValue = read_RYValue();
      pwmDutyCycleL = constrain(abs(joystick_LYValue), 0, 50);
      pwmDutyCycleR = constrain(abs(joystick_RYValue), 0, 50);
      switch (STATE) {
        case STOP:
          run_joySTOP();
          find_joyState();
          break;
        case FORWARD:
          run_joyFORWARD();
          find_joyState();
          break;
        case REVERSE:
          run_joyREVERSE();
          find_joyState();
          break;
        case SPINCL:
          run_joySPINCL();
          find_joyState();
          break;
        case SPINCCL:
          run_joySPINCCL();
          find_joyState();
          break;
        default:
          break;
      }
      if (PS4.Touchpad()) MODE = BUTTON_MODE;
      break;
    default:
      break;
  }
/*
--------------------------------------------------------------------------Above is the main switch state case statements for the robot, it reads which mode is being used------------
--------------------------------------------------------------------------to contorl the robot: either joystick or butotn, both using tank controls. It switches modes by pressing on
--------------------------------------------------------------------------the touchpad on the ps4 controller. This is a nested switch case state
*/
  switch (BODY) {
    case CONTACT:
      pwmDutyCycle = 25;
      PS4.end();
      run_FORWARD();
      delay(2000);
      run_STOP();
      run_openclaw();
      CLAWSTATE = OPENED;
      PS4.isConnected();
      find_bodystate();
      break;
    case SPACE:
      find_bodystate();
      break;
    default:
      break;
  }
  /*
--------------------------------------------------------------------------Above is the switch case statement for the body of the orbot, finding whether or not it --------------------------------
--------------------------------------------------------------------------is in contact with a wall or other physical object. Changes state by reading bumper vlaues
*/
}
